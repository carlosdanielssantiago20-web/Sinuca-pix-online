<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sinuca Pix Online</title>

<style>
body {
  margin: 0;
  background: radial-gradient(circle at top, #111, #000);
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  touch-action: none;
}

canvas {
  background: radial-gradient(circle, #0f6b3f, #064026);
  border-radius: 20px;
  box-shadow:
    0 0 40px rgba(0,255,150,0.3),
    inset 0 0 25px rgba(0,0,0,0.8);
}
</style>
</head>

<body>

<canvas id="game" width="360" height="640"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const table = {
  left: 30,
  right: canvas.width - 30,
  top: 30,
  bottom: canvas.height - 30
};

let pointer = { x: 0, y: 0 };
let shooting = false;

const balls = [];

const cueBall = {
  x: canvas.width / 2,
  y: canvas.height - 140,
  r: 10,
  vx: 0,
  vy: 0,
  color: "#ffffff"
};
balls.push(cueBall);

// bolas alvo
const colors = ["#f00","#00f","#ff0","#f0f","#0ff","#fa0"];
let startX = canvas.width / 2 - 55;
let startY = 120;

colors.forEach((c, i) => {
  balls.push({
    x: startX + i * 22,
    y: startY,
    r: 10,
    vx: 0,
    vy: 0,
    color: c
  });
});

// eventos touch + mouse
function setPointer(e) {
  const rect = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  pointer.x = t.clientX - rect.left;
  pointer.y = t.clientY - rect.top;
}

canvas.addEventListener("mousedown", e => {
  setPointer(e);
  if (Math.hypot(cueBall.vx, cueBall.vy) < 0.05) shooting = true;
});

canvas.addEventListener("mousemove", setPointer);
canvas.addEventListener("mouseup", () => shoot());

canvas.addEventListener("touchstart", e => {
  setPointer(e);
  if (Math.hypot(cueBall.vx, cueBall.vy) < 0.05) shooting = true;
});

canvas.addEventListener("touchmove", setPointer);
canvas.addEventListener("touchend", () => shoot());

function shoot() {
  if (!shooting) return;
  cueBall.vx = (cueBall.x - pointer.x) * 0.05;
  cueBall.vy = (cueBall.y - pointer.y) * 0.05;
  shooting = false;
}

function drawBall(b) {
  // sombra
  ctx.beginPath();
  ctx.arc(b.x + 3, b.y + 4, b.r, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fill();

  // brilho
  const g = ctx.createRadialGradient(
    b.x - 4, b.y - 4, 2,
    b.x, b.y, b.r
  );
  g.addColorStop(0, "#fff");
  g.addColorStop(0.4, b.color);
  g.addColorStop(1, "#000");

  ctx.beginPath();
  ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
  ctx.fillStyle = g;
  ctx.fill();
}

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // mesa
  ctx.strokeStyle = "#2b1b0f";
  ctx.lineWidth = 20;
  ctx.strokeRect(
    table.left - 10,
    table.top - 10,
    table.right - table.left + 20,
    table.bottom - table.top + 20
  );

  balls.forEach(b => {
    b.x += b.vx;
    b.y += b.vy;

    b.vx *= 0.98;
    b.vy *= 0.98;

    if (Math.abs(b.vx) < 0.01) b.vx = 0;
    if (Math.abs(b.vy) < 0.01) b.vy = 0;

    if (b.x - b.r < table.left || b.x + b.r > table.right) b.vx *= -1;
    if (b.y - b.r < table.top || b.y + b.r > table.bottom) b.vy *= -1;

    drawBall(b);
  });

  // mira
  if (shooting) {
    ctx.setLineDash([8, 8]);
    ctx.strokeStyle = "rgba(255,255,255,0.6)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cueBall.x, cueBall.y);
    ctx.lineTo(pointer.x, pointer.y);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  requestAnimationFrame(update);
}

update();
</script>

</body>
</html>
